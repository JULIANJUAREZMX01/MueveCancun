---
interface Props {
  center?: [number, number];
  zoom?: number;
}

const { center = [21.1619, -86.8515], zoom = 13 } = Astro.props;
---

<div id="map-container" class="w-full h-full relative" data-center={JSON.stringify(center)} data-zoom={zoom}>
    <!-- Map Element -->
    <div id="leaflet-map" class="w-full h-full z-0"></div>

    <!-- Map Controls (Custom) -->
    <div class="absolute bottom-24 right-4 z-[400] flex flex-col gap-2">
        <button id="gps-center-btn" class="w-10 h-10 bg-white rounded-xl shadow-lg flex items-center justify-center text-slate-600 hover:text-primary-500 transition-colors active:scale-95" aria-label="Centrar en mi ubicaci√≥n">
            <span class="material-symbols-rounded text-xl">my_location</span>
        </button>
    </div>
</div>

<script>
  import { coordinatesStore } from '../lib/CoordinatesStore';

  function escapeHtml(unsafe) {
    if (typeof unsafe !== 'string') return unsafe;
    return unsafe
         .replace(/&/g, "&amp;")
         .replace(/</g, "&lt;")
         .replace(/>/g, "&gt;")
         .replace(/"/g, "&quot;")
         .replace(/'/g, "&#039;");
  }

  function safeUrl(name) {
      if (typeof name !== 'string') return '';
      return encodeURIComponent(name).replace(/'/g, "%27");
  }

  let map;
  let layerGroup;
  let coordinatesDB = {};

  // Helper: Escape HTML
  function escapeHtml(unsafe) {
    if (unsafe === null || unsafe === undefined) return '';
    return String(unsafe)
         .replace(/&/g, "&amp;")
         .replace(/</g, "&lt;")
         .replace(/>/g, "&gt;")
         .replace(/"/g, "&quot;")
         .replace(/'/g, "&#039;");
  }

  async function initMap() {
    const container = document.getElementById('map-container');
    if (!container) return; // Not on a page with a map

    // CLEANUP: If map exists but container is new/different, destroy old map
    // Or if container has content (Leaflet artifact), clear it.
    if (map) {
        map.remove();
        map = null;
    }

    // Ensure Leaflet is loaded
    if (!window.L) {
        // Retry shortly
        setTimeout(initMap, 100);
        return;
    }

    const center = JSON.parse(container.dataset.center);
    const zoom = parseInt(container.dataset.zoom);

    map = window.L.map('leaflet-map', {
        zoomControl: false,
        attributionControl: false
    }).setView(center, zoom);

    // Add Tile Layer
    window.L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        maxZoom: 19
    }).addTo(map);

    // Load coordinates DB if needed (legacy fallback)
    try {
        const res = await fetch('/coordinates.json');
        if (res.ok) coordinatesDB = await res.json();
    } catch (e) {
        // console.warn("No legacy coordinates DB found");
    }

    if (loader) loader.classList.add('hidden');

    // Check for Picker Mode
    const urlParams = new URLSearchParams(window.location.search);
    const isPicker = urlParams.get('picker');

    if (isPicker) {
        if (window.showToast) window.showToast("Toque el mapa para seleccionar una parada cercana", "info");

        // Add visual indicator
        const indicator = document.createElement('div');
        indicator.className = 'absolute top-4 left-1/2 -translate-x-1/2 bg-primary-600 text-white px-4 py-2 rounded-full shadow-lg z-[1000] font-bold text-sm animate-bounce';
        indicator.textContent = "üìç Modo Selecci√≥n";
        container.parentElement.appendChild(indicator);

        map.on('click', (e) => {
            const { lat, lng } = e.latlng;

            // Use Store for Spatial Search
            const nearest = coordinatesStore.findNearest(lat, lng);
            let minDist = Infinity;

            if (nearest && coordinatesDB[nearest]) {
                 // Calculate distance to verify threshold (Store does it, but we need it for UI logic if we want strict < 1000m)
                 // Store fallback is 1.5km. Map logic was 1000m.
                 // We can trust the store or re-verify. Let's re-verify with Leaflet's distance to be consistent with previous logic.
                 const coords = coordinatesDB[nearest];
                 minDist = map.distance(e.latlng, coords);
            }

            // Threshold: 1000 meters
            if (nearest && minDist < 1000) {
                // Show confirmation popup at location
                window.L.popup()
                    .setLatLng(e.latlng)
                    .setContent(`
                        <div class="text-center">
                            <p class="font-bold mb-2">¬øSeleccionar "${escapeHtml(nearest)}"?</p>
                            <button id="confirm-pick-btn" class="bg-primary-500 text-white px-3 py-1 rounded text-xs font-bold">
                                ‚úÖ Confirmar
                            </button>
                        </div>
                    `)
                    .openOn(map);

                // Bind click to button (need delay for DOM)
                setTimeout(() => {
                    document.getElementById('confirm-pick-btn')?.addEventListener('click', () => {
                         window.location.href = `/?selected_stop=${encodeURIComponent(nearest)}`;
                    });
                }, 100);

            } else {
                 if (window.showToast) window.showToast("No hay paradas registradas cerca", "warning");
            }
        });

        // Return early to avoid drawing routes or default markers that might confuse
        return;
    }

    // Check for pending route from other pages
    const pendingRoute = localStorage.getItem('pending_route');
    if (pendingRoute) {
        try {
            const data = JSON.parse(pendingRoute);
            drawRoute(data);
            localStorage.removeItem('pending_route');
        } catch (e) {
            console.error("Error parsing pending route", e);
        }
    }


    // Draw all points from DB as refined markers
    if (!pendingRoute) {
        const newLayers = [];
        Object.entries(coordinatesDB).forEach(([name, coords]) => {
            const isRoute = name.startsWith('RUTA') || name.startsWith('Ruta');
            
            // Premium Marker Styling
            const marker = window.L.circleMarker(coords, {
                radius: isRoute ? 8 : 5,
                fillColor: isRoute ? '#F97316' : '#3B82F6',
                color: '#FFFFFF',
                weight: 2,
                opacity: 1,
                fillOpacity: 0.9
            }).bindPopup(`
                <div class="p-1">
                    <p class="font-bold text-gray-900">${escapeHtml(name)}</p>
                    <p class="text-xs text-gray-500">${isRoute ? 'üöå Ruta Detectada' : 'üìç Punto de Inter√©s'}</p>
                    <button onclick="window.location.href='/rutas?search=${safeUrl(name)}'" class="mt-2 w-full text-xs bg-primary-600 text-white rounded py-1 font-bold">Ver Detalles</button>
                </div>
            `);
            newLayers.push(marker);
        });
        
        if (newLayers.length > 0) {
            layerGroup = window.L.layerGroup(newLayers).addTo(map);
            // Optionally fit bounds to all points if database is not empty
            const allCoords = Object.values(coordinatesDB);
            if (allCoords.length > 0) {
                map.fitBounds(allCoords, { padding: [40, 40], maxZoom: 15 });
            }
        }
    }
  }


  function drawRoute(data) {
    if (!map) return;

    // Reset layers
    if (layerGroup) {
        layerGroup.clearLayers();
        layerGroup.remove();
    }
    layerGroup = window.L.layerGroup().addTo(map);

    // Normalize Data Structure
    // 'data' could be a full Journey (with legs) or a single Route object
    let legs = [];
    if (data.legs && Array.isArray(data.legs)) {
        legs = data.legs;
    } else if (data.paradas && Array.isArray(data.paradas)) {
        // Single route treated as one leg
        legs = [{ paradas: data.paradas, name: data.nombre || data.name }];
    } else if (data.stops && Array.isArray(data.stops)) {
        // Legacy format
        legs = [{ stops: data.stops, name: data.nombre || data.name }];
    } else {
        return; // Invalid data
    }

    const allBounds = [];

    legs.forEach((leg, index) => {
        const routeCoords = [];
        const validStops = [];

        // Try to get explicit coordinates from 'paradas' object array
        const stopsSource = leg.paradas || leg.stops_info || [];
        
        if (stopsSource.length > 0 && typeof stopsSource[0] === 'object') {
            // New Format: [{ lat, lng, nombre }, ...]
            stopsSource.forEach(stop => {
                if (stop.lat && stop.lng) {
                    const lat = parseFloat(stop.lat);
                    const lng = parseFloat(stop.lng); // Handle "lon" vs "lng" if needed
                    // Sometimes JSON has "lon" instead of "lng"
                    // Check logic:
                    const finalLng = !isNaN(lng) ? lng : parseFloat(stop.lon);

                    if (!isNaN(lat) && !isNaN(finalLng)) {
                        const coords = [lat, finalLng];
                        routeCoords.push(coords);
                        validStops.push({ name: stop.nombre || stop.name || 'Parada', latlng: coords });
                        allBounds.push(coords);
                    }
                }
            });
        } else {
            // Legacy: Array of strings + coordinatesDB
            const stopNames = leg.stops || [];
            stopNames.forEach(name => {
                if (coordinatesDB[name]) {
                    const coords = coordinatesDB[name];
                    routeCoords.push(coords);
                    validStops.push({ name: name, latlng: coords });
                    allBounds.push(coords);
                }
            });
        }

        if (routeCoords.length > 0) {
            const color = index === 0 ? '#F97316' : '#0EA5E9'; // Orange -> Blue for transfers
            const dashArray = index === 0 ? null : '10, 10';

            // Polyline
            window.L.polyline(routeCoords, {
                color, weight: 4, opacity: 0.8, dashArray
            }).addTo(layerGroup);

            // Start Marker (only for first leg)
            if (index === 0) {
                 const start = validStops[0];
                 newLayers.push(window.L.marker(start.latlng)
                    .bindPopup(`<b>Inicio:</b> ${escapeHtml(start.name)}`));
            }

            // End Marker (only for last leg)
            if (index === legs.length - 1) {
                 const end = validStops[validStops.length - 1];
                 newLayers.push(window.L.marker(end.latlng)
                    .bindPopup(`<b>Fin:</b> ${escapeHtml(end.name)}`));
            }

            // Transfer Marker (if not last leg)
            if (index < legs.length - 1) {
                const end = validStops[validStops.length - 1];
                 newLayers.push(window.L.marker(end.latlng, {
                     // Custom icon for transfer? Or just a marker.
                 }).bindPopup(`<b>Transbordo:</b> ${escapeHtml(end.name)}`));
            }

            // Intermediate dots
            validStops.slice(1, -1).forEach(stop => {
                 newLayers.push(
                    window.L.circleMarker(stop.latlng, { radius: 4, color: '#334155', fillOpacity: 1 })
                    .bindPopup(escapeHtml(stop.name))
                 );
            });

        } else {
            console.warn("No coordinates found for stops:", stops);
        }
    });

    if (allBounds.length > 0) {
        map.fitBounds(allBounds, { padding: [50, 50] });
    }
  }

  // --- Event Listeners ---

  window.addEventListener('SHOW_ROUTE_ON_MAP', (event) => {
      const { journey } = event.detail;
      drawRoute(journey);
  });

  // Cleanup on page swap (Astro)
  document.addEventListener('astro:before-swap', () => {
      if (map) {
          map.remove();
          map = null;
      }
  });

  // Re-init on page load
  document.addEventListener('astro:page-load', () => {
      initMap();
      setupGPS();
  });

  // Initial load
  if (document.readyState === 'complete') {
      initMap();
      setupGPS();
  } else {
      window.addEventListener('load', () => {
        initMap();
        setupGPS();
      });
  }

  // --- GPS Logic ---
  function setupGPS() {
      const btn = document.getElementById('gps-center-btn');
      if (!btn) return;

      btn.addEventListener('click', () => {
          if (!navigator.geolocation) return;
          btn.classList.add('animate-pulse', 'text-primary-500');

          navigator.geolocation.getCurrentPosition(pos => {
              btn.classList.remove('animate-pulse', 'text-primary-500');
              const { latitude, longitude } = pos.coords;
              if (map) {
                  map.setView([latitude, longitude], 15);
                  window.L.marker([latitude, longitude], {
                      icon: window.L.divIcon({
                          className: 'user-location-marker',
                          html: '<div class="pulse-ring"></div><div class="dot"></div>',
                          iconSize: [24, 24]
                      })
                  }).addTo(map);
              }
          }, () => {
              btn.classList.remove('animate-pulse', 'text-primary-500');
          });
      });
  }

</script>

<style is:global>
  .user-location-marker {
      display: flex;
      align-items: center;
      justify-content: center;
  }
  .user-location-marker .dot {
      width: 12px;
      height: 12px;
      background: #3B82F6;
      border: 2px solid white;
      border-radius: 50%;
      box-shadow: 0 0 8px rgba(0,0,0,0.3);
      z-index: 2;
  }
  .user-location-marker .pulse-ring {
      position: absolute;
      width: 30px;
      height: 30px;
      background: rgba(59, 130, 246, 0.4);
      border-radius: 50%;
      z-index: 1;
      animation: map-marker-pulse 2s infinite;
  }
  @keyframes map-marker-pulse {
      0% { transform: scale(0.5); opacity: 1; }
      100% { transform: scale(2.5); opacity: 0; }
  }
</style>
