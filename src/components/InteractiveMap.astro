---
interface Props {
  center?: [number, number];
  zoom?: number;
  class?: string;
}

const {
  center = [21.1619, -86.8515], // Canc√∫n
  zoom = 12,
  class: className = "relative w-full h-[500px] overflow-hidden rounded-xl border border-gray-200 shadow-inner z-0"
} = Astro.props;
---

<div class={className}>
  <div id="map-container" class="w-full h-full z-0" data-center={JSON.stringify(center)} data-zoom={zoom}></div>

  <div id="map-loader" class="absolute inset-0 flex items-center justify-center bg-gray-50 z-[1000]">
    <div class="text-center">
      <div class="animate-spin rounded-full h-12 w-12 border-4 border-primary-500 border-t-transparent mx-auto mb-4"></div>
      <p class="text-gray-600 font-medium">Cargando mapa...</p>
    </div>
  </div>
</div>

<script>
  let map;
  let layerGroup;
  let coordinatesDB = {};

  async function initMap() {
    const container = document.getElementById('map-container');
    const loader = document.getElementById('map-loader');

    if (!container || window.L === undefined) {
        console.warn("Leaflet not loaded or container missing");
        return;
    }

    if (container._leaflet_id) return; // Prevent double init

    const center = JSON.parse(container.dataset.center);
    const zoom = parseFloat(container.dataset.zoom);

    // Initialize Leaflet
    // Canc√∫n Bounds: [20.8, -87.3] to [21.6, -86.5]
    const maxBounds = [
        [20.8, -87.3], // South-West
        [21.6, -86.5]  // North-East
    ];

    map = window.L.map('map-container', {
        preferCanvas: true,
        maxBounds: maxBounds,
        maxBoundsViscosity: 1.0,
        minZoom: 10
    }).setView(center, zoom);

    window.L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        minZoom: 10,
        maxZoom: 18
    }).addTo(map);

    layerGroup = window.L.layerGroup().addTo(map);

    // Fetch Coordinates
    try {
        const res = await fetch('/coordinates.json');
        coordinatesDB = await res.json();
        console.log("Coordinates loaded:", Object.keys(coordinatesDB).length);
    } catch (e) {
        console.error("Failed to load coordinates:", e);
    }

    if (loader) loader.classList.add('hidden');

    // Check for Picker Mode
    const urlParams = new URLSearchParams(window.location.search);
    const isPicker = urlParams.get('picker');

    if (isPicker) {
        if (window.showToast) window.showToast("Toque el mapa para seleccionar una parada cercana", "info");

        // Add visual indicator
        const indicator = document.createElement('div');
        indicator.className = 'absolute top-4 left-1/2 -translate-x-1/2 bg-primary-600 text-white px-4 py-2 rounded-full shadow-lg z-[1000] font-bold text-sm animate-bounce';
        indicator.textContent = "üìç Modo Selecci√≥n";
        container.parentElement.appendChild(indicator);

        map.on('click', (e) => {
            const { lat, lng } = e.latlng;
            let minDist = Infinity;
            let nearest = '';

            // Leaflet map.distance returns meters
            Object.entries(coordinatesDB).forEach(([name, coords]) => {
                const d = map.distance(e.latlng, coords);
                if (d < minDist) {
                    minDist = d;
                    nearest = name;
                }
            });

            // Threshold: 1000 meters
            if (minDist < 1000 && nearest) {
                // Show confirmation popup at location
                window.L.popup()
                    .setLatLng(e.latlng)
                    .setContent(`
                        <div class="text-center">
                            <p class="font-bold mb-2">¬øSeleccionar "${nearest}"?</p>
                            <button id="confirm-pick-btn" class="bg-primary-500 text-white px-3 py-1 rounded text-xs font-bold">
                                ‚úÖ Confirmar
                            </button>
                        </div>
                    `)
                    .openOn(map);

                // Bind click to button (need delay for DOM)
                setTimeout(() => {
                    document.getElementById('confirm-pick-btn')?.addEventListener('click', () => {
                         window.location.href = `/?selected_stop=${encodeURIComponent(nearest)}`;
                    });
                }, 100);

            } else {
                 if (window.showToast) window.showToast("No hay paradas registradas cerca", "warning");
            }
        });

        // Return early to avoid drawing routes or default markers that might confuse
        return;
    }

    // Check for pending route from other pages
    const pendingRoute = localStorage.getItem('pending_route');
    if (pendingRoute) {
        try {
            const data = JSON.parse(pendingRoute);
            // Normalize to object if it's just an array of strings (legacy)
            if (Array.isArray(data)) {
                drawRoute({ stops: data });
            } else {
                drawRoute(data);
            }
            localStorage.removeItem('pending_route');
        } catch (e) {
            console.error("Error parsing pending route", e);
        }
    }

    // Default markers for key hubs if no route
    if (!pendingRoute) {
        const markers = [];
        Object.entries(coordinatesDB).forEach(([name, coords]) => {
            if (["El Crucero", "Zona Hotelera", "Aeropuerto T2", "Plaza Las Am√©ricas"].includes(name)) {
                 markers.push(window.L.marker(coords).bindPopup(`<b>${name}</b>`));
            }
        });
        markers.forEach(layer => layer.addTo(layerGroup));
    }
  }

  function getRouteColor(route) {
      const name = route.name || "";
      const type = route.transport_type || "";
      const lowerName = name.toLowerCase();

      // Riviera Maya (Teal)
      if (lowerName.includes("playa express") || lowerName.includes("ado") || type === "ADO" || type === "PlayaExpress" || type.includes("Van")) {
          return '#00B2A9';
      }

      // Costa Mujeres (Orange)
      if (lowerName.includes("puerto ju√°rez") || lowerName.includes("rehoyada") || lowerName.includes("muelle")) {
          return '#FF8200';
      }

      // Default Brand Orange
      return '#F97316';
  }

  function drawRoute(journey, userLocation = null) {
    if (!map) return;

    // Remove old layer group to avoid overhead during additions
    if (layerGroup) {
        layerGroup.clearLayers();
        layerGroup.remove();
    }

    // Handle Legacy Input (direct object without wrapper)
    const data = journey;

    // Normalize input to legs array
    let legs = [];
    if (data.legs && Array.isArray(data.legs)) {
        legs = data.legs;
    } else if (data.stops && Array.isArray(data.stops)) {
        legs = [{ stops: data.stops }];
    } else {
         layerGroup = window.L.layerGroup().addTo(map);
         return;
    }

    const newLayers = [];
    const allBounds = [];

    // Draw Gap (Walking Segment)
    if (userLocation && data.start_coords) {
         // Dashed Line from User to Start
         const gapLine = window.L.polyline([userLocation, data.start_coords], {
             color: '#64748b', // Slate-500
             weight: 4,
             dashArray: '10, 10',
             opacity: 0.8
         });
         newLayers.push(gapLine);

         // User Marker
         newLayers.push(window.L.circleMarker(userLocation, {
             radius: 8,
             color: '#ffffff',
             fillColor: '#3b82f6',
             fillOpacity: 1,
             weight: 2
         }).bindPopup("<b>Tu Ubicaci√≥n</b>"));

         allBounds.push(userLocation);
    }

    legs.forEach((leg, index) => {
        const stops = leg.stops || [];
        const routeCoords = [];
        const validStops = [];

        stops.forEach(stopName => {
            // Fuzzy match or exact match
            let coords = coordinatesDB[stopName];

            // Simple fuzzy fallback if exact missing (e.g. "Av. Kabah" vs "Hospital General (Av. Kabah)")
            if (!coords) {
                 const key = Object.keys(coordinatesDB).find(k => stopName.includes(k) || k.includes(stopName));
                 if (key) coords = coordinatesDB[key];
            }

            if (coords) {
                routeCoords.push(coords);
                validStops.push({ name: stopName, latlng: coords });
                allBounds.push(coords);
            } else {
                console.warn(`[InteractiveMap] Skipping stop with missing coordinates: ${stopName}`);
            }
        });

        if (routeCoords.length > 0) {
            // Style based on index (Leg 1 vs Leg 2)
            const isFirst = index === 0;
            // Use specific color for Leg 1, Blue for Leg 2 (Transfer)
            const color = index === 0 ? getRouteColor(leg) : '#3B82F6';

            // Visual distinction: Leg 2 is dashed if it's a transfer?
            // Usually transfers are solid too, but distinct color.
            // Requirement: "Render the Bus Route as a Solid Polyline".
            const dashArray = null;
            const weight = 5;

            const polyline = window.L.polyline(routeCoords, {
                color,
                weight,
                opacity: 0.8,
                dashArray
            });
            newLayers.push(polyline);

            // Start Marker (only for first leg)
            if (index === 0) {
                 const start = validStops[0];
                 newLayers.push(window.L.marker(start.latlng)
                    .bindPopup(`<b>Inicio Ruta:</b> ${start.name}`));
            }

            // End Marker (only for last leg)
            if (index === legs.length - 1) {
                 const end = validStops[validStops.length - 1];
                 newLayers.push(window.L.marker(end.latlng)
                    .bindPopup(`<b>Fin Ruta:</b> ${end.name}`));
            }

            // Transfer Marker (if not last leg)
            if (index < legs.length - 1) {
                const end = validStops[validStops.length - 1];
                 newLayers.push(window.L.marker(end.latlng).bindPopup(`<b>Transbordo:</b> ${end.name}`));
            }

            // Intermediate dots (optimized with Canvas via map preference)
            validStops.slice(1, -1).forEach(stop => {
                 newLayers.push(
                    window.L.circleMarker(stop.latlng, { radius: 4, color: '#334155', fillOpacity: 1 })
                    .bindPopup(stop.name)
                 );
            });

        } else {
            console.warn("No coordinates found for stops:", stops);
        }
    });

    if (newLayers.length > 0) {
        // Batch add to map
        layerGroup = window.L.layerGroup(newLayers).addTo(map);
        if (allBounds.length > 0) {
             map.fitBounds(allBounds, { padding: [50, 50] });
        }
    } else {
         if (window.showToast) window.showToast("No se pudieron visualizar los puntos de esta ruta.", "error");
         layerGroup = window.L.layerGroup().addTo(map);
    }
  }

  // Listen for global event
  window.addEventListener('SHOW_ROUTE_ON_MAP', (event) => {
    console.log("Event received:", event.detail);
    let journey = event.detail;
    let userLocation = null;

    // Normalize input
    if (event.detail.journey) {
         journey = event.detail.journey;
         userLocation = event.detail.userLocation;
    }

    drawRoute(journey, userLocation);
  });

  window.addEventListener('HIGHLIGHT_ROUTE', (event) => {
    // Ideally highlight one route and dim others, but for now just draw it
    // If we support multiple routes, we'd need to manage layers better.
    // Assuming simple redraw for now as per "InteractiveMap" simplicity.
    drawRoute(event.detail);
  });

  // Handle View State Change (Resize map)
  window.addEventListener('VIEW_STATE_CHANGE', (event) => {
      const state = event.detail.state; // 'search' or 'map'
      const container = document.getElementById('map-container');

      // We might need to invalidate size if container size changes via CSS
      setTimeout(() => {
          if (map) map.invalidateSize();
      }, 300);
  });

  // Init on load
  if (document.readyState === 'complete') {
      initMap();
  } else {
      window.addEventListener('load', initMap);
  }

  // Re-init on view transition
  document.addEventListener('astro:page-load', () => {
      // Small delay to ensure container exists
      setTimeout(initMap, 100);
  });

</script>
