---
interface Props {
  center?: [number, number];
  zoom?: number;
}

const {
  center = [21.1619, -86.8515], // Cancún
  zoom = 12
} = Astro.props;
---

<div class="relative w-full h-[500px] overflow-hidden rounded-xl border border-gray-200 shadow-inner z-0">
  <div id="map-container" class="w-full h-full z-0" data-center={JSON.stringify(center)} data-zoom={zoom}></div>

  <div id="map-loader" class="absolute inset-0 flex items-center justify-center bg-gray-50 z-[1000]">
    <div class="text-center">
      <div class="animate-spin rounded-full h-12 w-12 border-4 border-primary-500 border-t-transparent mx-auto mb-4"></div>
      <p class="text-gray-600 font-medium">Cargando mapa...</p>
    </div>
  </div>
</div>

<script>
  let map;
  let layerGroup;
  let coordinatesDB = {};

  async function initMap() {
    const container = document.getElementById('map-container');
    const loader = document.getElementById('map-loader');

    if (!container || window.L === undefined) {
        console.warn("Leaflet not loaded or container missing");
        return;
    }

    if (container._leaflet_id) return; // Prevent double init

    const center = JSON.parse(container.dataset.center);
    const zoom = parseFloat(container.dataset.zoom);

    // Initialize Leaflet
    // Cancún Bounds: [20.8, -87.3] to [21.6, -86.5]
    const maxBounds = [
        [20.8, -87.3], // South-West
        [21.6, -86.5]  // North-East
    ];

    map = window.L.map('map-container', {
        preferCanvas: true,
        maxBounds: maxBounds,
        maxBoundsViscosity: 1.0,
        minZoom: 10
    }).setView(center, zoom);

    window.L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        minZoom: 10,
        maxZoom: 18
    }).addTo(map);

    layerGroup = window.L.layerGroup().addTo(map);

    // Fetch Coordinates
    try {
        const res = await fetch('/coordinates.json');
        coordinatesDB = await res.json();
        console.log("Coordinates loaded:", Object.keys(coordinatesDB).length);
    } catch (e) {
        console.error("Failed to load coordinates:", e);
    }

    if (loader) loader.classList.add('hidden');

    // Check for pending route from other pages
    const pendingRoute = localStorage.getItem('pending_route');
    if (pendingRoute) {
        try {
            const data = JSON.parse(pendingRoute);
            // Normalize to object if it's just an array of strings (legacy)
            if (Array.isArray(data)) {
                drawRoute({ stops: data });
            } else {
                drawRoute(data);
            }
            localStorage.removeItem('pending_route');
        } catch (e) {
            console.error("Error parsing pending route", e);
        }
    }

    // Default markers for key hubs if no route
    if (!pendingRoute) {
        const markers = [];
        Object.entries(coordinatesDB).forEach(([name, coords]) => {
            if (["El Crucero", "Zona Hotelera", "Aeropuerto T2", "Plaza Las Américas"].includes(name)) {
                 markers.push(window.L.marker(coords).bindPopup(`<b>${name}</b>`));
            }
        });
        markers.forEach(layer => layer.addTo(layerGroup));
    }
  }

  function drawRoute(data) {
    if (!map) return;

    // Remove old layer group to avoid overhead during additions
    if (layerGroup) {
        layerGroup.clearLayers();
        layerGroup.remove();
    }

    // Normalize input to legs array
    let legs = [];
    if (data.legs && Array.isArray(data.legs)) {
        legs = data.legs;
    } else if (data.stops && Array.isArray(data.stops)) {
        legs = [{ stops: data.stops }];
    } else {
         layerGroup = window.L.layerGroup().addTo(map);
         return;
    }

    const newLayers = [];
    const allBounds = [];

    legs.forEach((leg, index) => {
        const stops = leg.stops || [];
        const routeCoords = [];
        const validStops = [];

        stops.forEach(stopName => {
            // Fuzzy match or exact match
            let coords = coordinatesDB[stopName];

            // Simple fuzzy fallback if exact missing (e.g. "Av. Kabah" vs "Hospital General (Av. Kabah)")
            if (!coords) {
                 const key = Object.keys(coordinatesDB).find(k => stopName.includes(k) || k.includes(stopName));
                 if (key) coords = coordinatesDB[key];
            }

            if (coords) {
                routeCoords.push(coords);
                validStops.push({ name: stopName, latlng: coords });
                allBounds.push(coords);
            } else {
                console.warn(`[InteractiveMap] Skipping stop with missing coordinates: ${stopName}`);
            }
        });

        if (routeCoords.length > 0) {
            // Style based on index (Leg 1 vs Leg 2)
            const isFirst = index === 0;
            const color = '#F97316';
            // Visual distinction: Leg 2 is dashed
            const dashArray = isFirst ? null : '10, 10';
            const weight = 4;

            const polyline = window.L.polyline(routeCoords, {
                color,
                weight,
                opacity: 0.8,
                dashArray
            });
            newLayers.push(polyline);

            // Start Marker (only for first leg)
            if (index === 0) {
                 const start = validStops[0];
                 newLayers.push(window.L.marker(start.latlng)
                    .bindPopup(`<b>Inicio:</b> ${start.name}`));
            }

            // End Marker (only for last leg)
            if (index === legs.length - 1) {
                 const end = validStops[validStops.length - 1];
                 newLayers.push(window.L.marker(end.latlng)
                    .bindPopup(`<b>Fin:</b> ${end.name}`));
            }

            // Transfer Marker (if not last leg)
            if (index < legs.length - 1) {
                const end = validStops[validStops.length - 1];
                 newLayers.push(window.L.marker(end.latlng, {
                     // Custom icon for transfer? Or just a marker.
                     // Using default marker but maybe distinct popup
                 }).bindPopup(`<b>Transbordo:</b> ${end.name}`));
            }

            // Intermediate dots (optimized with Canvas via map preference)
            validStops.slice(1, -1).forEach(stop => {
                 newLayers.push(
                    window.L.circleMarker(stop.latlng, { radius: 4, color: '#334155', fillOpacity: 1 })
                    .bindPopup(stop.name)
                 );
            });

        } else {
            console.warn("No coordinates found for stops:", stops);
        }
    });

    if (newLayers.length > 0) {
        // Batch add to map
        layerGroup = window.L.layerGroup(newLayers).addTo(map);
        if (allBounds.length > 0) {
             map.fitBounds(allBounds, { padding: [50, 50] });
        }
    } else {
         if (window.showToast) window.showToast("No se pudieron visualizar los puntos de esta ruta.", "error");
         layerGroup = window.L.layerGroup().addTo(map);
    }
  }

  // Listen for global event
  window.addEventListener('SHOW_ROUTE_ON_MAP', (event) => {
    console.log("Event received:", event.detail);
    drawRoute(event.detail);
  });

  // Init on load
  if (document.readyState === 'complete') {
      initMap();
  } else {
      window.addEventListener('load', initMap);
  }

  // Re-init on view transition
  document.addEventListener('astro:page-load', () => {
      // Small delay to ensure container exists
      setTimeout(initMap, 100);
  });

</script>
