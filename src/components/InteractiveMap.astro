---
interface Props {
  center?: [number, number];
  zoom?: number;
}

const {
  center = [21.1619, -86.8515], // CancÃºn
  zoom = 12
} = Astro.props;
---

<div class="relative w-full h-[500px] overflow-hidden rounded-xl border border-gray-200 shadow-inner z-0">
  <div id="map-container" class="w-full h-full z-0" data-center={JSON.stringify(center)} data-zoom={zoom}></div>

  <div id="map-loader" class="absolute inset-0 flex items-center justify-center bg-gray-50 z-[1000]">
    <div class="text-center">
      <div class="animate-spin rounded-full h-12 w-12 border-4 border-primary-500 border-t-transparent mx-auto mb-4"></div>
      <p class="text-gray-600 font-medium">Cargando mapa...</p>
    </div>
  </div>
</div>

<script>
  let map;
  let layerGroup;
  let coordinatesDB = {};
  let find_nearest_stop;

  async function loadWasm() {
      try {
        const wasmPath = new URL('/wasm/route-calculator/route_calculator.js', window.location.href).href;
        const module = await import(/* @vite-ignore */ wasmPath);
        await module.default();
        find_nearest_stop = module.find_nearest_stop;
      } catch(e) { console.error("WASM load failed in map", e); }
  }

  async function initMap() {
    const container = document.getElementById('map-container');
    const loader = document.getElementById('map-loader');

    await loadWasm();

    if (!container || window.L === undefined) {
        console.warn("Leaflet not loaded or container missing");
        return;
    }

    if (container._leaflet_id) return; // Prevent double init

    const center = JSON.parse(container.dataset.center);
    const zoom = parseFloat(container.dataset.zoom);

    // Initialize Leaflet
    // CancÃºn Bounds: [20.8, -87.3] to [21.6, -86.5]
    const maxBounds = [
        [20.8, -87.3], // South-West
        [21.6, -86.5]  // North-East
    ];

    map = window.L.map('map-container', {
        preferCanvas: true,
        maxBounds: maxBounds,
        maxBoundsViscosity: 1.0,
        minZoom: 10
    }).setView(center, zoom);

    // Expose map instance globally for resizing
    window.map = map;

    window.L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        minZoom: 10,
        maxZoom: 18
    }).addTo(map);

    layerGroup = window.L.layerGroup().addTo(map);

    // Fetch Coordinates
    try {
        const res = await fetch('/coordinates.json');
        coordinatesDB = await res.json();
        console.log("Coordinates loaded:", Object.keys(coordinatesDB).length);
    } catch (e) {
        console.error("Failed to load coordinates:", e);
    }

    if (loader) loader.classList.add('hidden');

    // Check for Picker Mode
    const urlParams = new URLSearchParams(window.location.search);
    const isPicker = urlParams.get('picker');

    if (isPicker) {
        if (window.showToast) window.showToast("Toque el mapa para seleccionar una parada cercana", "info");

        // Add visual indicator
        const indicator = document.createElement('div');
        indicator.className = 'absolute top-4 left-1/2 -translate-x-1/2 bg-primary-600 text-white px-4 py-2 rounded-full shadow-lg z-[1000] font-bold text-sm animate-bounce';
        indicator.textContent = "ðŸ“ Modo SelecciÃ³n";
        container.parentElement.appendChild(indicator);

        map.on('click', (e) => {
            const { lat, lng } = e.latlng;
            let nearest = '';
            let minDist = Infinity;

            if (find_nearest_stop) {
                nearest = find_nearest_stop(lat, lng, coordinatesDB);
                // We trust WASM to find nearest. But we might want to check distance too.
                // The current WASM implementation just finds nearest regardless of distance (min_dist logic was comment).
                // But in JS below we have 1000m threshold.
                // Let's rely on Leaflet distance check for threshold to be safe, or just assume nearest is fine if we trust user clicked near something.
                // Re-calculating distance to confirm it's close enough
                if (nearest && coordinatesDB[nearest]) {
                     minDist = map.distance(e.latlng, coordinatesDB[nearest]);
                }
            } else {
                // Leaflet map.distance returns meters
                Object.entries(coordinatesDB).forEach(([name, coords]) => {
                    const d = map.distance(e.latlng, coords);
                    if (d < minDist) {
                        minDist = d;
                        nearest = name;
                    }
                });
            }

            // Threshold: 1000 meters
            if (nearest && minDist < 1000) {
                // Show confirmation popup at location
                window.L.popup()
                    .setLatLng(e.latlng)
                    .setContent(`
                        <div class="text-center">
                            <p class="font-bold mb-2">Â¿Seleccionar "${nearest}"?</p>
                            <button id="confirm-pick-btn" class="bg-primary-500 text-white px-3 py-1 rounded text-xs font-bold">
                                âœ… Confirmar
                            </button>
                        </div>
                    `)
                    .openOn(map);

                // Bind click to button (need delay for DOM)
                setTimeout(() => {
                    document.getElementById('confirm-pick-btn')?.addEventListener('click', () => {
                         window.location.href = `/?selected_stop=${encodeURIComponent(nearest)}`;
                    });
                }, 100);

            } else {
                 if (window.showToast) window.showToast("No hay paradas registradas cerca", "warning");
            }
        });

        // Return early to avoid drawing routes or default markers that might confuse
        return;
    }

    // Check for pending route from other pages
    const pendingRoute = localStorage.getItem('pending_route');
    if (pendingRoute) {
        try {
            const data = JSON.parse(pendingRoute);
            // Normalize to object if it's just an array of strings (legacy)
            if (Array.isArray(data)) {
                drawRoute({ stops: data });
            } else {
                drawRoute(data);
            }
            localStorage.removeItem('pending_route');
        } catch (e) {
            console.error("Error parsing pending route", e);
        }
    }

    // Default markers for key hubs if no route
    if (!pendingRoute) {
        const markers = [];
        Object.entries(coordinatesDB).forEach(([name, coords]) => {
            if (["El Crucero", "Zona Hotelera", "Aeropuerto T2", "Plaza Las AmÃ©ricas"].includes(name)) {
                 markers.push(window.L.marker(coords).bindPopup(`<b>${name}</b>`));
            }
        });
        markers.forEach(layer => layer.addTo(layerGroup));
    }
  }

  function drawRoute(data) {
    if (!map) return;

    // Remove old layer group to avoid overhead during additions
    if (layerGroup) {
        layerGroup.clearLayers();
        layerGroup.remove();
    }

    // Normalize input to legs array
    let legs = [];
    if (data.legs && Array.isArray(data.legs)) {
        legs = data.legs;
    } else if (data.stops && Array.isArray(data.stops)) {
        legs = [{ stops: data.stops }];
    } else {
         layerGroup = window.L.layerGroup().addTo(map);
         return;
    }

    const newLayers = [];
    const allBounds = [];

    legs.forEach((leg, index) => {
        const stops = leg.stops || [];
        const routeCoords = [];
        const validStops = [];

        stops.forEach(stopName => {
            // Fuzzy match or exact match
            let coords = coordinatesDB[stopName];

            // Simple fuzzy fallback if exact missing (e.g. "Av. Kabah" vs "Hospital General (Av. Kabah)")
            if (!coords) {
                 const key = Object.keys(coordinatesDB).find(k => stopName.includes(k) || k.includes(stopName));
                 if (key) coords = coordinatesDB[key];
            }

            if (coords) {
                routeCoords.push(coords);
                validStops.push({ name: stopName, latlng: coords });
                allBounds.push(coords);
            } else {
                console.warn(`[InteractiveMap] Skipping stop with missing coordinates: ${stopName}`);
            }
        });

        if (routeCoords.length > 0) {
            // Style based on index (Leg 1 vs Leg 2)
            const isFirst = index === 0;
            const color = '#F97316';
            // Visual distinction: Leg 2 is dashed
            const dashArray = isFirst ? null : '10, 10';
            const weight = 4;

            const polyline = window.L.polyline(routeCoords, {
                color,
                weight,
                opacity: 0.8,
                dashArray
            });
            newLayers.push(polyline);

            // Start Marker (only for first leg)
            if (index === 0) {
                 const start = validStops[0];
                 newLayers.push(window.L.marker(start.latlng)
                    .bindPopup(`<b>Inicio:</b> ${start.name}`));
            }

            // End Marker (only for last leg)
            if (index === legs.length - 1) {
                 const end = validStops[validStops.length - 1];
                 newLayers.push(window.L.marker(end.latlng)
                    .bindPopup(`<b>Fin:</b> ${end.name}`));
            }

            // Transfer Marker (if not last leg)
            if (index < legs.length - 1) {
                const end = validStops[validStops.length - 1];
                 newLayers.push(window.L.marker(end.latlng, {
                     // Custom icon for transfer? Or just a marker.
                     // Using default marker but maybe distinct popup
                 }).bindPopup(`<b>Transbordo:</b> ${end.name}`));
            }

            // Intermediate dots (optimized with Canvas via map preference)
            validStops.slice(1, -1).forEach(stop => {
                 newLayers.push(
                    window.L.circleMarker(stop.latlng, { radius: 4, color: '#334155', fillOpacity: 1 })
                    .bindPopup(stop.name)
                 );
            });

        } else {
            console.warn("No coordinates found for stops:", stops);
        }
    });

    if (newLayers.length > 0) {
        // Batch add to map
        layerGroup = window.L.layerGroup(newLayers).addTo(map);
        if (allBounds.length > 0) {
             map.fitBounds(allBounds, { padding: [50, 50] });
        }
    } else {
         if (window.showToast) window.showToast("No se pudieron visualizar los puntos de esta ruta.", "error");
         layerGroup = window.L.layerGroup().addTo(map);
    }
  }

  // Listen for global event
  window.addEventListener('SHOW_ROUTE_ON_MAP', (event) => {
    console.log("Event received:", event.detail);
    drawRoute(event.detail);
  });

  function setupLazyLoad() {
      const container = document.getElementById('map-container');
      if (!container || container._leaflet_id) return;

      // Use IntersectionObserver to init map only when visible
      const observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
              if (entry.isIntersecting) {
                  console.log("Map container visible, initializing...");
                  initMap();
                  observer.disconnect();
              }
          });
      });
      observer.observe(container);
  }

  // Init on load
  if (document.readyState === 'complete') {
      setupLazyLoad();
  } else {
      window.addEventListener('load', setupLazyLoad);
  }

  // Re-init on view transition
  document.addEventListener('astro:page-load', () => {
      // Small delay to ensure container exists
      setTimeout(setupLazyLoad, 100);
  });

</script>
