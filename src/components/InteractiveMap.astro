---
interface Props {
  center?: [number, number];
  zoom?: number;
}

const {
  center = [21.1619, -86.8515], // Cancun Center
  zoom = 12
} = Astro.props;
---

<div class="relative w-full h-full min-h-[300px] overflow-hidden rounded-xl border border-gray-200 shadow-inner z-0">
  <div id="map-container" class="w-full h-full z-0" data-center={JSON.stringify(center)} data-zoom={zoom}></div>

  <div id="map-loader" class="absolute inset-0 flex items-center justify-center bg-gray-50 z-[1000]">
    <div class="text-center">
      <div class="animate-spin rounded-full h-12 w-12 border-4 border-primary-500 border-t-transparent mx-auto mb-4"></div>
      <p class="text-gray-600 font-medium">Cargando mapa...</p>
    </div>
  </div>
</div>

<script>
  import { coordinatesStore } from '../lib/CoordinatesStore';

  // Optimized Coordinate Finder (Inverted Index + Cache)
  class CoordinateFinder {
      constructor(db) {
          this.db = db;
          this.cache = new Map();
          this.tokenIndex = new Map();
          this.keys = Object.keys(db);
          this.buildIndex();
      }

      buildIndex() {
          for (const key of this.keys) {
              // Tokenize: split by non-alphanumeric (including Spanish accents)
              const tokens = key.toLowerCase().split(/[^a-z0-9\u00C0-\u017F]+/);
              for (const token of tokens) {
                  if (token.length < 3) continue;
                  if (!this.tokenIndex.has(token)) {
                      this.tokenIndex.set(token, []);
                  }
                  this.tokenIndex.get(token).push(key);
              }
          }
      }

      find(stopName) {
          // 1. Exact match
          if (this.db[stopName]) return this.db[stopName];

          // 2. Cache check
          if (this.cache.has(stopName)) return this.cache.get(stopName);

          // 3. Fuzzy Search
          const searchTokens = stopName.toLowerCase().split(/[^a-z0-9\u00C0-\u017F]+/);
          const candidates = new Set();

          for (const token of searchTokens) {
              if (token.length < 3) continue;
              const matches = this.tokenIndex.get(token);
              if (matches) {
                  for (const m of matches) candidates.add(m);
              }
          }

          let bestKey = null;
          if (candidates.size > 0) {
               // Prefer candidates that are substrings or contain the query
               bestKey = Array.from(candidates).find(k => stopName.includes(k) || k.includes(stopName));
          }

          const result = bestKey ? this.db[bestKey] : null;
          this.cache.set(stopName, result);
          return result;
      }
  }

  function escapeHtml(unsafe) {
    if (typeof unsafe !== 'string') return unsafe;
    return unsafe
         .replace(/&/g, "&amp;")
         .replace(/</g, "&lt;")
         .replace(/>/g, "&gt;")
         .replace(/"/g, "&quot;")
         .replace(/'/g, "&#039;");
  }

  function safeUrl(name) {
      return encodeURIComponent(name).replace(/'/g, '%27');
  }

  let map;
  let layerGroup;
  let coordinatesDB = {};
  let finder;       // Para b√∫squeda de nombres

  async function initMap() {
    const container = document.getElementById('map-container');
    const loader = document.getElementById('map-loader');

    if (!container || window.L === undefined) {
        console.warn("Leaflet not loaded or container missing");
        return;
    }

    if (container._leaflet_id) return; // Prevent double init

    const center = JSON.parse(container.dataset.center);
    const zoom = parseFloat(container.dataset.zoom);

    // Initialize Leaflet
    // Canc√∫n Bounds: [20.8, -87.3] to [21.6, -86.5]
    const maxBounds = [
        [20.8, -87.3], // South-West
        [21.6, -86.5]  // North-East
    ];

    map = window.L.map('map-container', {
        preferCanvas: true,
        maxBounds: maxBounds,
        maxBoundsViscosity: 1.0,
        minZoom: 10
    }).setView(center, zoom);

    window.L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        minZoom: 10,
        maxZoom: 18
    }).addTo(map);

    layerGroup = window.L.layerGroup().addTo(map);

    // Initialize Shared Store
    try {
        await coordinatesStore.init();
        coordinatesDB = coordinatesStore.getDB() || {};
        console.log("Coordinates loaded from store:", Object.keys(coordinatesDB).length);

        // 1. Init Text Finder (Fuzzy Search)
        finder = new CoordinateFinder(coordinatesDB);

    } catch (e) {
        console.error("Failed to load coordinates:", e);
    }

    if (loader) loader.classList.add('hidden');

    // Check for Picker Mode
    const urlParams = new URLSearchParams(window.location.search);
    const isPicker = urlParams.get('picker');

    if (isPicker) {
        if (window.showToast) window.showToast("Toque el mapa para seleccionar una parada cercana", "info");

        // Add visual indicator
        const indicator = document.createElement('div');
        indicator.className = 'absolute top-4 left-1/2 -translate-x-1/2 bg-primary-600 text-white px-4 py-2 rounded-full shadow-lg z-[1000] font-bold text-sm animate-bounce';
        indicator.textContent = "üìç Modo Selecci√≥n";
        container.parentElement.appendChild(indicator);

        map.on('click', (e) => {
            const { lat, lng } = e.latlng;

            // Use Store for Spatial Search
            const nearest = coordinatesStore.findNearest(lat, lng);
            let minDist = Infinity;

            if (nearest && coordinatesDB[nearest]) {
                 // Calculate distance to verify threshold (Store does it, but we need it for UI logic if we want strict < 1000m)
                 // Store fallback is 1.5km. Map logic was 1000m.
                 // We can trust the store or re-verify. Let's re-verify with Leaflet's distance to be consistent with previous logic.
                 const coords = coordinatesDB[nearest];
                 minDist = map.distance(e.latlng, coords);
            }

            // Threshold: 1000 meters
            if (nearest && minDist < 1000) {
                // Show confirmation popup at location
                window.L.popup()
                    .setLatLng(e.latlng)
                    .setContent(`
                        <div class="text-center">
                            <p class="font-bold mb-2">¬øSeleccionar "${escapeHtml(nearest)}"?</p>
                            <button id="confirm-pick-btn" class="bg-primary-500 text-white px-3 py-1 rounded text-xs font-bold">
                                ‚úÖ Confirmar
                            </button>
                        </div>
                    `)
                    .openOn(map);

                // Bind click to button (need delay for DOM)
                setTimeout(() => {
                    document.getElementById('confirm-pick-btn')?.addEventListener('click', () => {
                         window.location.href = `/?selected_stop=${encodeURIComponent(nearest)}`;
                    });
                }, 100);

            } else {
                 if (window.showToast) window.showToast("No hay paradas registradas cerca", "warning");
            }
        });

        // Return early to avoid drawing routes or default markers that might confuse
        return;
    }

    // Check for pending route from other pages
    const pendingRoute = localStorage.getItem('pending_route');
    if (pendingRoute) {
        try {
            const data = JSON.parse(pendingRoute);
            // Normalize to object if it's just an array of strings (legacy)
            if (Array.isArray(data)) {
                drawRoute({ stops: data });
            } else {
                drawRoute(data);
            }
            localStorage.removeItem('pending_route');
        } catch (e) {
            console.error("Error parsing pending route", e);
        }
    }

    // Draw all points from DB as refined markers
    if (!pendingRoute) {
        const newLayers = [];
        Object.entries(coordinatesDB).forEach(([name, coords]) => {
            const isRoute = name.startsWith('RUTA') || name.startsWith('Ruta');
            
            // Premium Marker Styling
            const marker = window.L.circleMarker(coords, {
                radius: isRoute ? 8 : 5,
                fillColor: isRoute ? '#F97316' : '#3B82F6',
                color: '#FFFFFF',
                weight: 2,
                opacity: 1,
                fillOpacity: 0.9
            }).bindPopup(`
                <div class="p-1">
                    <p class="font-bold text-gray-900">${escapeHtml(name)}</p>
                    <p class="text-xs text-gray-500">${isRoute ? 'üöå Ruta Detectada' : 'üìç Punto de Inter√©s'}</p>
                    <button onclick="window.location.href='/rutas?search=${safeUrl(name)}'" class="mt-2 w-full text-xs bg-primary-600 text-white rounded py-1 font-bold">Ver Detalles</button>
                </div>
            `);
            newLayers.push(marker);
        });
        
        if (newLayers.length > 0) {
            layerGroup = window.L.layerGroup(newLayers).addTo(map);
            // Optionally fit bounds to all points if database is not empty
            const allCoords = Object.values(coordinatesDB);
            if (allCoords.length > 0) {
                map.fitBounds(allCoords, { padding: [40, 40], maxZoom: 15 });
            }
        }
    }
  }

  function drawRoute(data) {
    if (!map) return;

    // Remove old layer group to avoid overhead during additions
    if (layerGroup) {
        layerGroup.clearLayers();
        layerGroup.remove();
    }

    // Normalize input to legs array
    let legs = [];
    if (data.legs && Array.isArray(data.legs)) {
        legs = data.legs;
    } else if (data.stops && Array.isArray(data.stops)) {
        legs = [{ stops: data.stops }];
    } else {
         layerGroup = window.L.layerGroup().addTo(map);
         return;
    }

    const newLayers = [];
    const allBounds = [];

    legs.forEach((leg, index) => {
        const routeCoords = [];
        const validStops = [];

        // ‚ö° SPEEDY: Use pre-computed coordinates from WASM if available (stops_info)
        // This avoids the O(N) fuzzy search loop in JS
        if (leg.stops_info && leg.stops_info.length > 0) {
             leg.stops_info.forEach(stop => {
                 const coords = [stop.lat, stop.lng];
                 routeCoords.push(coords);
                 validStops.push({ name: stop.name, latlng: coords });
                 allBounds.push(coords);
             });
        } else {
            const stops = leg.stops || [];
            stops.forEach(stopName => {
                let coords;

                // Use Fuzzy Finder if available (Robust)
                if (finder) {
                    coords = finder.find(stopName);
                } else {
                    // Fallback
                    coords = coordinatesDB[stopName];
                    if (!coords) {
                         const key = Object.keys(coordinatesDB).find(k => stopName.includes(k) || k.includes(stopName));
                         if (key) coords = coordinatesDB[key];
                    }
                }

                if (coords) {
                    routeCoords.push(coords);
                    validStops.push({ name: stopName, latlng: coords });
                    allBounds.push(coords);
                } else {
                    console.warn(`[InteractiveMap] Skipping stop with missing coordinates: ${stopName}`);
                }
            });
        }

        if (routeCoords.length > 0) {
            // Style based on index (Leg 1 vs Leg 2)
            const isFirst = index === 0;
            const color = '#F97316';
            // Visual distinction: Leg 2 is dashed
            const dashArray = isFirst ? null : '10, 10';
            const weight = 4;

            const polyline = window.L.polyline(routeCoords, {
                color,
                weight,
                opacity: 0.8,
                dashArray
            });
            newLayers.push(polyline);

            // Start Marker (only for first leg)
            if (index === 0) {
                 const start = validStops[0];
                 newLayers.push(window.L.marker(start.latlng)
                    .bindPopup(`<b>Inicio:</b> ${escapeHtml(start.name)}`));
            }

            // End Marker (only for last leg)
            if (index === legs.length - 1) {
                 const end = validStops[validStops.length - 1];
                 newLayers.push(window.L.marker(end.latlng)
                    .bindPopup(`<b>Fin:</b> ${escapeHtml(end.name)}`));
            }

            // Transfer Marker (if not last leg)
            if (index < legs.length - 1) {
                const end = validStops[validStops.length - 1];
                 newLayers.push(window.L.marker(end.latlng, {
                     // Custom icon for transfer? Or just a marker.
                 }).bindPopup(`<b>Transbordo:</b> ${escapeHtml(end.name)}`));
            }

            // Intermediate dots
            validStops.slice(1, -1).forEach(stop => {
                 newLayers.push(
                    window.L.circleMarker(stop.latlng, { radius: 4, color: '#334155', fillOpacity: 1 })
                    .bindPopup(escapeHtml(stop.name))
                 );
            });

        } else {
            console.warn("No coordinates found for stops:", stops);
        }
    });

    if (newLayers.length > 0) {
        // Batch add to map
        layerGroup = window.L.layerGroup(newLayers).addTo(map);
        if (allBounds.length > 0) {
             map.fitBounds(allBounds, { padding: [50, 50] });
        }
    } else {
         if (window.showToast) window.showToast("No se pudieron visualizar los puntos de esta ruta.", "error");
         layerGroup = window.L.layerGroup().addTo(map);
    }
  }

  // Listen for global event
  window.addEventListener('SHOW_ROUTE_ON_MAP', (event) => {
    console.log("Event received:", event.detail);
    drawRoute(event.detail);
  });

  // Init on load
  if (document.readyState === 'complete') {
      initMap();
  } else {
      window.addEventListener('load', initMap);
  }

  // Re-init on view transition
  document.addEventListener('astro:page-load', () => {
      // Small delay to ensure container exists
      setTimeout(initMap, 100);
  });

</script>
