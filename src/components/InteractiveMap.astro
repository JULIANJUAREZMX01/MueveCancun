---
interface Props {
  center?: [number, number];
  zoom?: number;
}

const { center = [21.1619, -86.8515], zoom = 13 } = Astro.props;
---

<div id="map-container" class="w-full h-full relative" data-center={JSON.stringify(center)} data-zoom={zoom}>
    <!-- Map Element -->
    <div id="leaflet-map" class="w-full h-full z-0"></div>

    <!-- Map Controls (Custom) -->
    <div class="absolute bottom-24 right-4 z-[400] flex flex-col gap-2">
        <button id="gps-center-btn" class="w-10 h-10 bg-white rounded-xl shadow-lg flex items-center justify-center text-slate-600 hover:text-primary-500 transition-colors active:scale-95" aria-label="Centrar en mi ubicación">
            <span class="material-symbols-rounded text-xl">my_location</span>
        </button>
    </div>
</div>

<script>
  // Ensure we have access to Leaflet
  // It is loaded in MainLayout via CDN for performance

  let map;
  let layerGroup;
  let coordinatesDB = {};
  let dbKeys = []; // Cache for keys to avoid re-scan
  let fuzzyCache = new Map(); // Cache for fuzzy results
  let finder; // Fuzzy finder instance

  // Helper: Escape HTML (Security: prevent XSS in popups)
  function escapeHtml(unsafe) {
    if (unsafe === null || unsafe === undefined) return '';
    return String(unsafe)
         .replace(/&/g, "&amp;")
         .replace(/</g, "&lt;")
         .replace(/>/g, "&gt;")
         .replace(/"/g, "&quot;")
         .replace(/'/g, "&#039;");
  }

  async function initMap() {
    const container = document.getElementById('map-container');
    if (!container) return;

    // Prevent double init
    if (map) {
        // Just invalidate size if resizing happened
        map.invalidateSize();
        return;
    }

    const center = JSON.parse(container.dataset.center);
    const zoom = parseInt(container.dataset.zoom);

    // Wait for Leaflet to load
    if (!window.L) {
        console.warn("Leaflet not loaded yet, retrying...");
        setTimeout(initMap, 100);
        return;
    }

    map = window.L.map('leaflet-map', {
        zoomControl: false, // We'll add custom controls if needed
        attributionControl: false
    }).setView(center, zoom);

    // Add Tile Layer (CartoDB Positron for clean look)
    window.L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        maxZoom: 19
    }).addTo(map);

    // Load coordinates DB for markers
    try {
        const res = await fetch('/coordinates.json');
        if (res.ok) {
            coordinatesDB = await res.json();
            dbKeys = Object.keys(coordinatesDB); // Update keys cache
            fuzzyCache.clear(); // Clear cache on new DB load
            // Initialize Fuse.js for fuzzy finding if needed
            // (Optional, if we want to search stops on map click)
        }
    } catch (e) {
        console.error("Failed to load coordinates DB", e);
    }

    // Check for pending route to draw (from SSR redirection or state)
    const pendingRoute = localStorage.getItem('pending_route');
    if (pendingRoute) {
        try {
            const data = JSON.parse(pendingRoute);
            // Normalize to object if it's just an array of strings (legacy)
            if (Array.isArray(data)) {
                drawRoute({ stops: data });
            } else {
                drawRoute(data);
            }
            localStorage.removeItem('pending_route');
        } catch (e) {
            console.error("Error parsing pending route", e);
        }
    }
  }

  function drawRoute(data) {
    if (!map) return;

    // Remove old layer group to avoid overhead during additions
    if (layerGroup) {
        layerGroup.clearLayers();
        layerGroup.remove();
    }

    // Normalize input to legs array
    let legs = [];
    if (data.legs && Array.isArray(data.legs)) {
        legs = data.legs;
    } else if (data.stops && Array.isArray(data.stops)) {
        legs = [{ stops: data.stops }];
    } else if (data.paradas && Array.isArray(data.paradas)) {
        legs = [{ stops: data.paradas }];
    } else {
         layerGroup = window.L.layerGroup().addTo(map);
         return;
    }

    const newLayers = [];
    const allBounds = [];

    legs.forEach((leg, index) => {
        const routeCoords = [];
        const validStops = [];

        // ⚡ SPEEDY: Use pre-computed coordinates from WASM if available (stops_info, paradas or stops)
        // This avoids the O(N) fuzzy search loop in JS
        const stopsData = leg.stops_info || leg.paradas || leg.stops || [];
        
        if (stopsData.length > 0 && typeof stopsData[0] === 'object' && stopsData[0].lat !== undefined) {
             stopsData.forEach(stop => {
                 const coords = [stop.lat, stop.lng];
                 routeCoords.push(coords);
                 validStops.push({ name: stop.nombre || stop.name, latlng: coords });
                 allBounds.push(coords);
             });
        } else {
            const stops = leg.stops || [];
            stops.forEach(stopName => {
                let coords = coordinatesDB[stopName];
                // Simple fallback if exact match fails
                if (!coords) {
                     if (fuzzyCache.has(stopName)) {
                         coords = fuzzyCache.get(stopName);
                     } else {
                         // Fallback logic using cached keys
                         const key = dbKeys.find(k => stopName.includes(k) || k.includes(stopName));
                         if (key) coords = coordinatesDB[key];

                         // Cache result (even if undefined to avoid re-scan)
                         fuzzyCache.set(stopName, coords);
                     }
                }

                if (coords) {
                    routeCoords.push(coords);
                    validStops.push({ name: stopName, latlng: coords });
                    allBounds.push(coords);
                }
            });
        }

        if (routeCoords.length > 0) {
            // Style based on index (Leg 1 vs Leg 2)
            const isFirst = index === 0;
            const color = '#F97316';
            // Visual distinction: Leg 2 is dashed
            const dashArray = isFirst ? null : '10, 10';
            const weight = 4;

            const polyline = window.L.polyline(routeCoords, {
                color,
                weight,
                opacity: 0.8,
                dashArray
            });
            newLayers.push(polyline);

            // Start Marker (only for first leg)
            if (index === 0) {
                 const start = validStops[0];
                 newLayers.push(window.L.marker(start.latlng)
                    .bindPopup(`<b>Inicio:</b> ${escapeHtml(start.name)}`));
            }

            // End Marker (only for last leg)
            if (index === legs.length - 1) {
                 const end = validStops[validStops.length - 1];
                 newLayers.push(window.L.marker(end.latlng)
                    .bindPopup(`<b>Fin:</b> ${escapeHtml(end.name)}`));
            }

            // Transfer Marker (if not last leg)
            if (index < legs.length - 1) {
                const end = validStops[validStops.length - 1];
                 newLayers.push(window.L.circleMarker(end.latlng, {
                     radius: 6, color: '#0EA5E9', fillOpacity: 1
                 }).bindPopup(`<b>Transbordo:</b> ${escapeHtml(end.name)}`));
            }

            // Intermediate dots
            validStops.slice(1, -1).forEach(stop => {
                 newLayers.push(
                    window.L.circleMarker(stop.latlng, { radius: 3, color: '#334155', fillOpacity: 1, weight: 0 })
                    // .bindPopup(stop.name) // Too noisy
                 );
            });

        }
    });

    if (newLayers.length > 0) {
        // Batch add to map
        layerGroup = window.L.layerGroup(newLayers).addTo(map);
        if (allBounds.length > 0) {
             map.fitBounds(allBounds, { padding: [50, 50] });
        }
    } else {
         if (window.showToast) window.showToast("No se pudieron visualizar los puntos de esta ruta.", "error");
         layerGroup = window.L.layerGroup().addTo(map);
    }
  }

  // Listen for global event
  window.addEventListener('SHOW_ROUTE_ON_MAP', (event) => {
    console.log("Event received:", event.detail);
    const { journey, userLocation } = event.detail;
    drawRoute(journey);

    // If user location is provided, show it too
    if (userLocation && map) {
        // Draw user marker logic here if needed
    }
  });

  // GPS Centering Logic (Smart GPS)
  function setupGPS() {
    const gpsBtn = document.getElementById('gps-center-btn');
    if (!gpsBtn) return;

    let userMarker;

    const locateUser = (silent = false) => {
        if (!navigator.geolocation) {
            if (!silent && window.showToast) window.showToast("Geolocalización no disponible", "error");
            return;
        }

        if (!silent) gpsBtn.classList.add('animate-pulse', 'text-primary-500');

        navigator.geolocation.getCurrentPosition((pos) => {
            const { latitude, longitude } = pos.coords;
            
            // Save permission granted
            localStorage.setItem('gps_permission', 'true');

            if (map) {
                map.setView([latitude, longitude], 15);
                
                if (userMarker) userMarker.remove();
                
                const L = window.L;
                userMarker = L.marker([latitude, longitude], {
                    icon: L.divIcon({
                        className: 'user-location-marker',
                        html: '<div class="pulse-ring"></div><div class="dot"></div>',
                        iconSize: [24, 24]
                    })
                }).addTo(map);
            }
            
            if (!silent) {
                gpsBtn.classList.remove('animate-pulse', 'text-primary-500');
                if (window.showToast) window.showToast("Ubicación centrada", "info");
            }
        }, (err) => {
            console.error(err);
            if (!silent) {
                gpsBtn.classList.remove('animate-pulse', 'text-primary-500');
                if (window.showToast) window.showToast("No se pudo obtener la ubicación", "error");
            }
        });
    };

    gpsBtn.addEventListener('click', () => locateUser(false));

    // Smart Auto-Center: Check if permission was previously granted
    if (localStorage.getItem('gps_permission') === 'true') {
        // Wait a bit for map to init
        setTimeout(() => locateUser(true), 1000);
    }

    // Also listen for external location updates (from Search bar, etc)
    window.addEventListener('USER_LOCATION_UPDATE', (e) => {
        const { lat, lng, focus } = e.detail;
        if (map && focus) {
            map.setView([lat, lng], 15);
        }
    });
  }

  // Init on load
  if (document.readyState === 'complete') {
      initMap();
      setupGPS();
  } else {
      window.addEventListener('load', () => {
          initMap();
          setupGPS();
      });
  }

  // Re-init on view transition
  document.addEventListener('astro:page-load', () => {
      // Small delay to ensure container exists
      setTimeout(() => {
          initMap();
          setupGPS();
      }, 100);
  });

</script>

<style is:global>
  .user-location-marker {
      display: flex;
      align-items: center;
      justify-content: center;
  }
  .user-location-marker .dot {
      width: 12px;
      height: 12px;
      background: #3B82F6;
      border: 2px solid white;
      border-radius: 50%;
      box-shadow: 0 0 8px rgba(0,0,0,0.3);
      z-index: 2;
  }
  .user-location-marker .pulse-ring {
      position: absolute;
      width: 30px;
      height: 30px;
      background: rgba(59, 130, 246, 0.4);
      border-radius: 50%;
      z-index: 1;
      animation: map-marker-pulse 2s infinite;
  }
  @keyframes map-marker-pulse {
      0% { transform: scale(0.5); opacity: 1; }
      100% { transform: scale(2.5); opacity: 0; }
  }
</style>
